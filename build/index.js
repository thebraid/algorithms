!function(e){var t={};function n(o){if(t[o])return t[o].exports;var i=t[o]={i:o,l:!1,exports:{}};return e[o].call(i.exports,i,i.exports,n),i.l=!0,i.exports}n.m=e,n.c=t,n.d=function(e,t,o){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:o})},n.r=function(e){Object.defineProperty(e,"__esModule",{value:!0})},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=24)}([function(e){e.exports=[{name:"module1",depend:"module2"},{name:"module2",depend:"module3"},{name:"module2",depend:"module4"},{name:"module3",depend:"module4"},{name:"module4",depend:"module1"}]},function(e){e.exports=[{name:"module1",depend:"module2"},{name:"module2",depend:"module3"},{name:"module2",depend:"module4"},{name:"module3",depend:"module4"},{name:"module5",depend:"module4"},{name:"module8",depend:"module7"},{name:"module8",depend:"module6"},{name:"module7",depend:"module4"},{name:"module6",depend:"module5"}]},function(e,t){const n=[{from:0,to:1,km:1},{from:1,to:3,km:4},{from:3,to:4,km:4},{from:0,to:2,km:3},{from:2,to:4,km:7},{from:5,to:3,km:9},{from:5,to:0,km:3},{from:3,to:7,km:2},{from:4,to:8,km:1},{from:8,to:7,km:2},{from:2,to:6,km:6},{from:6,to:4,km:3},{from:6,to:7,km:4}];window.floid=new class{constructor(e,t,n,o){this.cities=e,this.roads=t,this.start=n,this.end=o,this.citiesRoads=Object.assign({}),this.matrix=[]}fillCityRoads(){const{citiesRoads:e}=this;n.forEach(({from:t,to:n,km:o})=>{e[t]||(e[t]=[]),e[n]||(e[n]=[]),e[t].push({to:n,km:o}),e[n].push({to:t,km:o})})}initMatrix(){const e=this.cities.length;for(let t=0;t<e;t+=1){this.matrix[t]=[];for(let n=0;n<e;n+=1)t!==n?this.matrix[t].push("-"):this.matrix[t].push(0)}}firstFill(){const{citiesRoads:e}=this;for(let t in e)e[t].forEach(({to:e,km:n})=>{this.matrix[t][e]={from:Number(t),to:e,km:n}})}getTotalDistance(e){return Array.isArray(e)?e.reduce((e,t)=>e+t.km,0):e.km}recursiveFill(e=0){const t=this.cities.length;if(e===t)return;const{matrix:n}=this;for(let o=0;o<t;o+=1)if(o!==e)for(let i=0;i<t;i+=1){if(i===e)continue;if(0===n[o][i])continue;if("-"===n[e][i])continue;if("-"===n[o][e])continue;const t=[].concat(n[o][e],n[e][i]);"-"!==n[o][i]&&this.getTotalDistance(n[o][i])<this.getTotalDistance(t)||(this.matrix[o][i]=[].concat(n[o][e],n[e][i]))}e++,this.recursiveFill(e)}getPath(){const{matrix:e,start:t,end:n,cities:o}=this,i=e[t][n];if(Array.isArray(i)){let e="";for(let t=0;t<i.length;t+=1)e=0!==t?t!==i.length-1?`${e} > ${o[i[t].from]}(${i[t].from})`:`${e} > ${o[i[t].from]}(${i[t].from}) > ${o[i[t].to]}(${i[t].to})`:`${o[i[t].from]}(${i[t].from})`;return e}return i.from}showResult(){const{matrix:e,start:t,end:n}=this,o=this.getTotalDistance(e[t][n]);console.log(`Минимальное рассояние от точки ${t} до ${n}: ${o}km`);const i=this.getPath();console.log(`Необходимо пройти следующий путь: ${i}\n\n`)}changeStart(e){e!==this.start?e!==this.end?e>this.cities.length-1?console.log(`Введенное значение ${e} слишком велико. Max значение: ${this.cities.length-1}`):(this.start=e,this.showResult()):console.log("Введеное значение равно месту назначения"):console.log("Введеное значение равно текущему")}changeEnd(e){e!==this.start?e!==this.end?e>this.cities.length-1?console.log(`Введенное значение ${e} слишком велико. Max значение: ${this.cities.length-1}`):(this.end=e,this.showResult()):console.log("Введеное значение равно текущему"):console.log("Введеное значение равно начальному месту ")}init(){document.getElementById("app").innerHTML='<img src="./src/other/findPath/Floid/graph.png"/>',this.fillCityRoads(),this.initMatrix(),this.search()}search(){this.firstFill(),this.recursiveFill(),this.showResult()}}(["zero","one","two","three","four","five","six","seven","eight"],n,0,4),floid.init()},function(e,t){window.randomInteger=((...e)=>{if(0===e.length)console.log(Math.round(Math.random()));else if(1===e.length){const t=e[0];console.log(Math.round(Math.random()*t))}else{let[t,n]=e;t>n&&([t,n]=[n,t]),console.log(Math.round(t+Math.random()*(n-t)))}})},function(e,t,n){"use strict";n.r(t);var o=n(1),i=n(0);window.modules=new class{constructor(e){this.store=new Map,this.resultImport=[],this.history=Object.create(null),this.isError=!1,this.depends=e}initStore(){const{depends:e,store:t}=this;e.forEach(({name:e,depend:n})=>{t.has(e)||t.set(e,new Set),t.get(e).add({depend:n})})}recurciveFindPaths(e,t){const{history:n,resultImport:o,store:i}=this;if(n[e])return;const s=Array.from(i.get(e));for(let r=0;r<s.length;r++){const l=s[r];if(!n[l.depend]){if(t[l.depend])return console.log(`циклическая зависимость на модуле ${e} => ${l.depend}`),void(this.isError=!0);i.has(l.depend)?(t[l.depend]=!0,this.recurciveFindPaths(l.depend,t),o.push(l.depend),n[l.depend]=!0):(t[l.depend]=!0,o.push(l.depend),n[l.depend]=!0)}}}findPaths(){const{store:e,resultImport:t,history:n}=this;for(let o of e.keys()){if(n[o])continue;const e=Object.create(null);e[o]=!0,this.recurciveFindPaths(o,e),t.push(o),n[o]=!0}}showResult(){const{isError:e,resultImport:t}=this;e||console.log(t)}init(){this.initStore(),this.findPaths(),this.showResult()}reset(){this.store.clear(),this.resultImport=[],this.history=Object.create(null),this.isError=!1}changeDepends(e){this.reset(),this.depends=e,this.init()}makeMistake(){this.changeDepends(i)}}(o)},function(e,t){window.bracketsBalance=function(e="{asda asdadasd (asdasd} 5434534}"){const t=[],n={"{":!0,"(":!0,"[":!0},o={"}":"{",")":"(","]":"["};for(let i=0;i<e.length;i++)if(n[e[i]])t.push(e[i]);else if(o[e[i]]){if(t[t.length-1]!==o[e[i]]){console.log(`исходный текст: "${e}"`),console.log(`ошибка на позиции ${i}`);const t=e.slice(0,i-1);return void console.log(`ошибка возникла здесь: "${t}>>${e[i]}<<"`)}t.pop()}t.length?console.log("не закрыты все скобки"):console.log("ошибок нет")}},function(e,t){window.rectAndLine=new class{constructor(){this.rectCoords=[-250,250,-250,250],this.rectWidth=Math.abs(this.rectCoords[1]-this.rectCoords[0]),this.rectHeight=Math.abs(this.rectCoords[3]-this.rectCoords[2]),this.pointA=[-50,-50],this.pointB=[50,50],this.result=[]}findCrossingPoint(e,t,n,o){const[i,s]=e,[r,l]=t,[c,a]=n,[d,u]=o,h=(d*(s*r-l*i-a*r+a*i)+c*(l*i-s*r+u*r-u*i))/(u*(r-i)+a*(i-r)+l*(c-d)+s*(d-c));if(Math.abs(h)===1/0)return console.log("Данные прямые:"),console.log(e,t),console.log(n,o),console.log("Параллельны друг другу"),null;const f=(h*(l-s)-l*i+s*r)/(r-i);return isNaN(f)?null:[h,f]}clear(){const e=document.getElementById("canvas");e&&e.remove()}isNotIdenticalResult([e,t]){let n=!0;return this.result.forEach(([o,i])=>{o===e&&i===t&&(n=!1)}),n}findCrossingPoints(){const[e,t,n,o]=this.rectCoords,i=[e,n],s=[e,o],r=[t,o],l=[t,n];[[i,s],[s,r],[r,l],[l,i]].forEach(([i,s])=>{const r=this.findCrossingPoint(this.pointA,this.pointB,i,s);r&&(r[0]>t||r[0]<e||r[1]>o||r[1]<n||r&&this.isNotIdenticalResult(r)&&this.result.push(r))})}drawRectangle(){const{rectWidth:e,rectHeight:t}=this;this.clear();const n=document.createElement("canvas");n.id="canvas",n.width=e,n.height=t;const o=n.getContext("2d");o.beginPath(),o.moveTo(0,0),o.lineTo(e,0),o.lineTo(e,t),o.lineTo(0,t),o.closePath(),o.strokeStyle="black",o.stroke(),document.getElementById("app").appendChild(n)}drawTextCoords(e,t,n){const{rectWidth:o,rectHeight:i,rectCoords:s}=this,[r,l,c,a]=s;e.font="12pt Arial",e.fillText("0:0",t,i-n+12),e.fillText(`${r}:${c}`,12,i-12),e.fillText(`${r}:${a}`,12,20),e.fillText(`${l}:${a}`,o-70,20),e.fillText(`${l}:${c}`,o-70,i-12)}drawAxis(){const e=document.getElementById("canvas").getContext("2d"),{rectWidth:t,rectHeight:n}=this,{rectCoords:o}=this,i=o[0],s=o[2],r=i<0?-i:0,l=s<0?-s:0;this.drawTextCoords(e,r,l),e.beginPath(),e.moveTo(0,n-l),e.lineTo(t,n-l),e.strokeStyle="red",e.stroke(),e.beginPath(),e.moveTo(r,0),e.lineTo(r,n),e.strokeStyle="red",e.stroke()}drawLine(){const{rectHeight:e}=this;if(this.findCrossingPoints(),2!==this.result.length)return console.log(this.result),void console.log("Нет точек пересечений");const t=document.getElementById("canvas").getContext("2d"),n=this.rectCoords[0],o=this.rectCoords[2],i=n<0?-n:0,s=o<0?-o:0,[r,l]=this.result;t.beginPath(),t.moveTo(r[0]+i,e-r[1]-s),t.lineTo(l[0]+i,e-l[1]-s),t.strokeStyle="black",t.stroke()}drawInputPanel(){if(document.getElementById("rectAndLine"))return;const e=document.getElementById("template_rectAndLine"),t=document.importNode(e.content,!0).children[0];document.getElementById("app").appendChild(t)}init(){document.getElementById("app").innerHTML="",this.draw()}draw(){this.resetResult(),this.drawInputPanel(),this.drawRectangle(),this.drawAxis(),this.drawLine()}resetResult(){this.result=[]}setRectCoords(e,t,n,o){t<e&&([e,t]=[t,e],console.log(`х2 < x1, меняем их значениями. х1 = ${e}; x2 = ${t}`)),o<n&&([n,o]=[o,n],console.log(`y2 < y1, меняем их значениями. y1 = ${n}; x2 = ${o}`)),this.rectCoords=[e,t,n,o],this.rectWidth=Math.abs(t-e),this.rectHeight=Math.abs(o-n),this.draw()}setPoints(e,t){this.pointA=e,this.pointB=t,this.draw()}handlerChangeRectCoords(){const e=document.getElementsByClassName("rectAndLine__input")[0].value;if(!e)return void console.log("Необходимо ввести данные");let t=e.split(",").map(Number);if(4!==t.length)return void console.log("Необходимо ввести 4 числа");const[n,o,i,s]=t;this.setRectCoords(n,o,i,s)}handlerChangePointsCoords(){const e=document.getElementsByClassName("rectAndLine__input")[1].value,t=document.getElementsByClassName("rectAndLine__input")[2].value;if(!e&&!t)return void console.log("Необходимо ввести координаты обоих точек");let n=e.split(",").map(Number),o=t.split(",").map(Number);2===n.length&&2===o.length?this.setPoints(n,o):console.log("Необходимо ввести по 2 числа для каждой точки")}}},function(e,t){window.chess=function(e=8){const t=[];function n(t,n,o){for(let i=-e;i<e;i++){if(0===i)continue;const s=n-i,r=o-i;s>=0&&s<e&&r>=0&&r<e&&(t[s][r]="*");const l=o+i;s>=0&&s<e&&l>=0&&l<e&&(t[s][l]="*")}}function o(t,o,i){for(let s=0;s<e;s++)for(let r=0;r<e;r++)s!==o||r!==i?(n(t,o,i),s!==o&&r!==i||(t[s][r]="*")):t[s][r]=1}function i(n){const i=function(){const t=[];for(let n=1;n<=e;n++)t.push(new Array(e).fill("-"));return t}();let s=0;o(i,s,n),function n(i,s){if(s!==e)for(let t=0;t<e;t++){if("*"===i[s][t]||1===i[s][t])continue;let e=JSON.parse(JSON.stringify(i));o(e,s,t),n(e,s+1)}else t.push(i)}(i,++s)}for(let t=0;t<e;t++)i(t);console.log(t)}},function(e,t){window.polindrom=((e="таррат")=>{console.log(`исходные текст: ${e}`);let t=!0;for(let n=0,o=e.length-1;n<e.length&&n!==o;n++,o--)e[n]!==e[o]&&(t=!1);console.log(`${t?"Полиндром":"Не полиндром"} \n\n`)})},function(e,t){window.findSimpleNumber1=((e=100)=>{const t=Array(e+1).fill(!0),n=[2];for(let e=4;e<t.length;e+=2)t[e]=!1;for(let o=3;o<t.length;o+=2){if(!t[o])continue;n.push(o);let i=2*o;for(;i<e;)t[i]=!1,i+=o}console.log(n)}),window.findSimpleNumber2=((e=100)=>{const t=[];e:for(let n=2;n<=e;n++){for(let e=2;e<n;e++)if(n%e==0)continue e;t.push(n)}console.log(t)}),window.findSimpleNumber3=((e=100)=>{const t=[2];e:for(let n=3;n<=e;n+=2){for(let e=3;e<n;e+=2)if(n%e==0)continue e;t.push(n)}console.log(t)})},function(e,t){const n={value:1,items:[{value:2,items:[{value:4,items:[{value:7},{value:8,items:[{value:11},{value:12}]}]},{value:5,items:[{value:9},{value:10}]}]},{value:3,items:[{value:6}]}]};window.treeWidth=function(e=n){const{value:t,items:o}=e;console.log(t),function e(t){let n=[];t.forEach(e=>{console.log(e.value),e.items&&(n=[...n,...e.items])}),n.length&&e(n)}(o)},treeWidth.default=n},function(e,t){const n={value:1,items:[{value:2,items:[{value:4},{value:5}]},{value:3,items:[{value:6}]}]};window.treeDeep=function(e=n){const{value:t,items:o}=e;console.log(t),o&&o.map(treeDeep)},treeDeep.default=n},function(e,t){const n={value:"a",child:{value:"b",child:{value:"c",child:{value:"d",child:{value:"e",child:null}}}}};window.revertList=function(e=n,t=null){let o;null===e.child?(o={value:e.value,child:t},console.log(`Исходный list: \n ${JSON.stringify(n)}`),console.log(`Результат: \n ${JSON.stringify(o)}`)):(o={value:e.value,child:t},revertList(e.child,o))},revertList.default=n},function(e,t){const n=function(e){const t=Array(e);for(let n=0;n<e;n++)t[n]=n+1;return t}(10);window.binarySearch=((e=5,t=n)=>{console.log(`\n Ищем значение ${e} в массиве:`),console.log(t);const o=t.length-1;let i=0,s=o;e>t[o]?console.log(`Значение ${e} нет в массиве`):function n(){if(s-i==1)return t[i]===e?void console.log(i):t[s]===e?void console.log(s):void console.log("найденного значения нет");let o=Math.floor((s+i)/2);e<t[o]?(s=o,n()):e>t[o]?(i=o,n()):console.log(`index = ${o} \n `)}()})},function(e,t){const n=function(){let e=1;return function(t){e>=4&&(e=0);const n=t[e];return e++,n}}();function o(e,t,n,o,i){return e+=n,[e=i[t=i[t+=o]&&"-"===i[t][e]?t:t-o][e]&&"-"===i[t][e]?e:e-n,t]}function i(e,t){const n=t.toString().length;let o=e.toString();for(;o.length<n;)o="0"+o;return o}window.arraySpiral=function(e=4,t){const s=e*(t=t||e),r=[[1,0],[0,1],[-1,0],[0,-1]],l=function(e,t){const n=[];t=t||e;for(let o=0;o<t;o++)n[o]=Array(e).fill("-");return n}(e,t);let c,a,d=0,u=0;[c,a]=r[0];for(let e=1;e<=s;e++)e=i(e,s),l[u]&&l[u][d]&&"-"===l[u][d]?(l[u][d]=e,[d,u]=o(d,u,c,a,l)):([c,a]=n(r),[d,u]=o(d,u,c,a,l),l[u][d]=e,[d,u]=o(d,u,c,a,l));console.dir(l)}},function(e,t){const n=[{name:"test1",value:53},{name:"test2",value:2}];window.reduceArray=function(e=n){const t={};for(let n=0;n<e.length;n++)t[e[n].name]=e[n].value;console.log(t)}},function(e,t){window.quickSort=function(){console.log(function e(t=[...defaultArray]){if(0===t.length)return[];const n=[],o=[],i=t[0];for(let e=1;e<t.length;e++)t[e]<i?n.push(t[e]):o.push(t[e]);return e(n).concat(i,e(o))}())}},function(e,t){window.mergeSort=function(e=[...defaultArray]){let t=[];for(let n=0;n<e.length;n+=1)t.push([e[n]]);for(;t.length>1;){const e=[];for(let n=0;n<t.length;n+=2){const o=t[n],i=t[n+1],s=[];if(!i){e.push(o);break}for(;o.length||i.length;)0!==o.length?0!==i.length&&o[0]>i[0]?(s.push(i[0]),i.splice(0,1)):(s.push(o[0]),o.splice(0,1)):(s.push(i[0]),i.splice(0,1));e.push(s)}t=e}console.log(t[0])}},function(e,t){window.insertSort=function(e=[...defaultArray]){let t=e.length-1;for(let n=0;n<=t;n++){if(0===n)continue;let t=n;for(;t&&e[t]<e[t-1];){let n=e[t];e[t]=e[t-1],e[t-1]=n,t-=1}}console.log(e)}},function(e,t){window.choiceSort=function(e=[...defaultArray]){let t=e.length;function n(e){let n=e[0],o=0;for(let i=0;i<t;i++)e[i]>n&&(n=e[i],o=i);return o}for(;0!==t;){let o=n(e);if(o===t){t-=1;continue}const i=e[t-1];e[t-1]=e[o],e[o]=i,t-=1}console.log(e)}},function(e,t){window.bubbleSort=function(e=[...defaultArray]){let t=e.length;for(;t;)n(e),t-=1;function n(e){for(let t=0;t<e.length-1;t++){let n=e[t],o=e[t+1];if(void 0===o)return;n>o&&(e[t]=o,e[t+1]=n)}}console.log(e)}},function(e,t){window.callSortAll=function(){console.log("\n сортировка bubbleSort"),bubbleSort(),console.log("\n сортировка choiceSort"),choiceSort(),console.log("\n сортировка insertSort"),insertSort(),console.log("\n сортировка mergeSort"),mergeSort(),console.log("\n сортировка quickSort"),quickSort(),console.log("\n")}},function(e,t){window.man=(()=>console.log('\nдемо https://thebraid.github.io/algorithms/\n\n1. Сортировка массивов.\n   По умолчанию все функции сортировок используют массив defaultArray = [6, 5, 3, -1, 0, -2, 8, 7, 2, 4, -16, 12, 54, 12, 65].\n   Его можно изменить через глобальную переменную "defaultArray" и все сортировки будут брать этот массив.\n   Или можно передавать нужный массив как 1й аргумент в функцию.\n   Каждая из сортировок не меняет defaultArray.\n   \n   1.0) callSortAll()      - вызовет по очереди все сортировки с массивом по умолчанию.\n   1.1) bubbleSort(array)  - пузырьковая сортировка\n   1.2) choiceSort(array)  - сортировка выбором\n   1.3) insertSort(array)  - сортировка вставками\n   1.4) mergeSort(array)   - сортировка слиянием\n   1.5) quickSort(array)   - быстрая сортировка\n   \n2) Поиск простых чисел\n   Аргумент по умолчанию 100 - т.е. все простые числа до 100.\n\n   2.1) findSimpleNumber1(N) - первый вариант нахождения простых чисел\n   2.2) findSimpleNumber2(N) - улучшенный 1й вариант\n   2.3) findSimpleNumber3(N) - финальный вариант (улучшенный 2й вариант).\n   \n3) Заполнить массив по спирали \n  arraySpiral(NxM) где N = 4 по умолчанию,M = N по умолчанию\n  \n  пример вызова:\n    arraySpiral();    // 4x4\n    arraySpiral(5);   // 5x5\n    arraySpiral(5,7); // 5x7\n    \n4) Бинарный поиск по массиву\n    binarySearch(elem, array), где\n    elem  - элемент который ищем в массиве, по умолчанию = 5;\n    array - массив поиска, по умолчанию = [1,2,3,4,5,6,7,8,9,10]. Массив должен быть упорядоченным.\n    \n5) Баланс скобок в строке.\n   bracketBalance(str), где str по умолчанию = \'{asda asdadasd (asdasd} 5434534}\' (строка с ошибкой)\n   \n6) Расставить ферзей.\n   chess(N), где N по умолчанию = 8 (размер поля 8х8 и ищем расстановку 8 ферзей).\n   Можно задавать размер поля любым, но при значении 12 и свыше вычисления будут занимать длительное время.\n   \n7) Разворот обьекта в обратную сторону.\n  revertList(obj), для просмотра obj по умолчанию набрать "revertList.default"\n \n8) Обход дерева в глубину\n   treeDeep(tree), для просмотра tree по умолчанию набрать "treeDeep.default"\n\n9) Обход дерева в ширину\n   treeWidth(tree), для просмотра tree по умолчанию набрать "treeWidth.default"\n\n10) Нахождение пересечения прямоугольника с координатами x1,x2,y1,y2 с заданными координатами 2 точек прямой.\n   10.1) rectAndLine.draw() - нарисует по умолчанию прямоугольник x1=-250, x2=250, y1=-250, y2=250 и прямую с координатами точек [-5, 1] и [4, 2].\n   10.2) rectAndLine.setRectCoords(x1, x2, y1, y2); - изменит координаты прямоугольника\n   10.3) rectAndLine.setPoints([x1, y1], [x2, y2]);   - изменит координаты точек прямой\n     \n11) Проверка строки на полиндром\n    polindrom(str), str по умолчанию = \'таррат\'\n    \n12) Получение целого числа в заданном диапазоне.\n    randomInteger(), или 0 или 1\n    randomInteger(max), от 0 до max\n    randomInteger(min, max), от min до max\n\n13) Нахождение оптимального пути между графами\n    floid.init() - выведет результат поиска по установленному графу в консоль ( + отобразит заднный граф на экране).\n    floid.changeStart(index) - изменит начальную позицию. \n    floid.changeEnd(index) - изменит конечную позицию. \n\n14) Импорт модулей в зависимости от их зависимостей, с проверкой на зацикленность.\n    modules.init() - выведет результат о предустановленных зависимостях.\n    modules.changeDepends(newDepends) - задает новые зависимости и отображает результат.\n    modules.makeMistake() - изменит текущие зависимости но новые с циклической зависимостью.\n    \n    modules.depends - покажет текущие зависимости.\n'))},function(e,t,n){window.defaultArray=[6,5,3,-1,0,-2,8,7,2,4,-16,12,54,12,65];n(22),n(21),n(20),n(19),n(18),n(17),n(16),n(15),n(14),n(13),n(12),n(11),n(10),n(9),n(8),n(7),n(6),n(5),n(4),n(3),n(2)},function(e,t,n){e.exports=n(23)}]);