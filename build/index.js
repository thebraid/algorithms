!function(t){var e={};function n(o){if(e[o])return e[o].exports;var s=e[o]={i:o,l:!1,exports:{}};return t[o].call(s.exports,s,s.exports,n),s.l=!0,s.exports}n.m=t,n.c=e,n.d=function(t,e,o){n.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:o})},n.r=function(t){Object.defineProperty(t,"__esModule",{value:!0})},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=35)}([function(t){t.exports=[{name:"module1",depend:"module2"},{name:"module2",depend:"module3"},{name:"module2",depend:"module4"},{name:"module3",depend:"module4"},{name:"module4",depend:"module1"}]},function(t){t.exports=[{name:"module1",depend:"module2"},{name:"module2",depend:"module3"},{name:"module2",depend:"module4"},{name:"module3",depend:"module4"},{name:"module5",depend:"module4"},{name:"module8",depend:"module7"},{name:"module8",depend:"module6"},{name:"module7",depend:"module4"},{name:"module6",depend:"module5"}]},function(t,e){},function(t,e){window.dijkstra=new class{constructor(t,e,n,o){this.cities=t,this.roads=e,this.start=n,this.end=o,this.citiesRoads=Object.create(null),this.history=Object.create(null)}fillCityRoads(){const{citiesRoads:t,roads:e}=this;e.forEach(({from:e,to:n,km:o})=>{t[e]||(t[e]=[]),t[n]||(t[n]=[]),t[e].push({from:e,to:n,km:o}),t[n].push({from:n,to:e,km:o})})}init(){document.getElementById("app").innerHTML='<img src="./src/other/findPath/common/graph.png"/>',console.log("Алгоритм Дийсктры"),this.fillCityRoads(),this.search()}getDistance(t){if(null===t)return 1/0;if(Array.isArray(t)){let e=0;return t.forEach(t=>{e+=t.km}),e}return t.km}recurciveSearch(t){if(t.every(t=>t.done))return;const{citiesRoads:e,history:n}=this;let o=[];t.forEach(t=>{const{start:s,nodes:i}=t;n[s]={...n[s],done:!0},i.forEach(t=>{if(n[t.to]&&n[t.to].done)return;if(n[t.to]){const e=n[t.to].path,o=this.getDistance(e);if(isFinite(o)){const e=this.getDistance(n[t.from].path),o=this.getDistance(t);if(this.getDistance(n[t.to].path)<e+o)return;n[t.to]={...n[t.to],path:n[t.from].path.concat(t)}}else n[t.to]={...n[t.to],path:[t]}}else{let e=[];const o=n[t.from].path;e=o?o.concat(t):[t],n[t.to]={done:!1,path:e}}let i=e[t.to];i=i.filter(t=>t.to!==s),o=o.concat({start:t.to,nodes:i})})}),this.count++,this.recurciveSearch(o)}search(){const{citiesRoads:t,start:e}=this,n=t[e];this.recurciveSearch([{start:e,nodes:n}]),this.showResult()}showResult(){const{start:t,end:e}=this;console.log(this.history);const n=this.history[e].path,o=this.getDistance(n);let s="";for(let t=0;t<n.length;t++)0!==t?(n.length,s+=` > ${n[t].to}`):s+=`${n[t].from} > ${n[t].to}`;console.log(`Минимальное рассояние от точки ${t} до ${e}: ${o}km`),console.log(`Необходимо пройти следующий путь: ${s}\n\n`)}validate(t){return t===this.start?(console.log("Введеное значение равно точке старта"),!1):t===this.end?(console.log("Введеное значение равно точке назначения"),!1):t>this.cities.length-1?(console.log(`Введенное значение ${t} слишком велико. Max значение: ${this.cities.length-1}`),!1):!(t<0&&(console.log(`Введенное значение ${t} не может быть меньше 0`),1))}clear(){this.history=Object.create(null)}changeEnd(t){this.validate(t)&&(this.end=t,this.showResult())}changeStart(t){this.validate(t)&&(this.clear(),this.start=t,this.search())}}(["zero","one","two","three","four","five","six","seven","eight"],[{from:0,to:1,km:1},{from:1,to:3,km:4},{from:3,to:4,km:4},{from:0,to:2,km:3},{from:2,to:4,km:7},{from:5,to:3,km:9},{from:5,to:0,km:3},{from:3,to:7,km:2},{from:4,to:8,km:1},{from:8,to:7,km:2},{from:2,to:6,km:6},{from:6,to:4,km:3},{from:6,to:7,km:4}],0,4)},function(t,e){const n=[{from:0,to:1,km:1},{from:1,to:3,km:4},{from:3,to:4,km:4},{from:0,to:2,km:3},{from:2,to:4,km:7},{from:5,to:3,km:9},{from:5,to:0,km:3},{from:3,to:7,km:2},{from:4,to:8,km:1},{from:8,to:7,km:2},{from:2,to:6,km:6},{from:6,to:4,km:3},{from:6,to:7,km:4}];window.floid=new class{constructor(t,e,n,o){this.cities=t,this.roads=e,this.start=n,this.end=o,this.citiesRoads=Object.create(null),this.matrix=[]}fillCityRoads(){const{citiesRoads:t}=this;n.forEach(({from:e,to:n,km:o})=>{t[e]||(t[e]=[]),t[n]||(t[n]=[]),t[e].push({to:n,km:o}),t[n].push({to:e,km:o})})}initMatrix(){const t=this.cities.length;for(let e=0;e<t;e+=1){this.matrix[e]=[];for(let n=0;n<t;n+=1)e!==n?this.matrix[e].push("-"):this.matrix[e].push(0)}}firstFill(){const{citiesRoads:t}=this;for(let e in t)t[e].forEach(({to:t,km:n})=>{this.matrix[e][t]={from:Number(e),to:t,km:n}})}getTotalDistance(t){return Array.isArray(t)?t.reduce((t,e)=>t+e.km,0):t.km}recursiveFill(t=0){const e=this.cities.length;if(t===e)return;const{matrix:n}=this;for(let o=0;o<e;o+=1)if(o!==t)for(let s=0;s<e;s+=1){if(s===t)continue;if(0===n[o][s])continue;if("-"===n[t][s])continue;if("-"===n[o][t])continue;const e=[].concat(n[o][t],n[t][s]);"-"!==n[o][s]&&this.getTotalDistance(n[o][s])<this.getTotalDistance(e)||(this.matrix[o][s]=[].concat(n[o][t],n[t][s]))}t++,this.recursiveFill(t)}getPath(){const{matrix:t,start:e,end:n,cities:o}=this,s=t[e][n];if(Array.isArray(s)){let t="";for(let e=0;e<s.length;e+=1)0!==e?e!==s.length-1?t+=`> ${o[s[e].to]}(${s[e].to})`:t+=` > ${o[s[e].to]}(${s[e].to})`:t+=`${o[s[e].from]}(${s[e].from}) > ${o[s[e].to]}(${s[e].to})`;return t}return`${s.from} > ${s.to}`}showResult(){const{matrix:t,start:e,end:n}=this,o=this.getTotalDistance(t[e][n]);console.log(`Минимальное рассояние от точки ${e} до ${n}: ${o}km`);const s=this.getPath();console.log(`Необходимо пройти следующий путь: ${s}\n\n`),console.log(this.citiesRoads)}validate(t){return t===this.start?(console.log("Введеное значение равно точке старта"),!1):t===this.end?(console.log("Введеное значение равно точке назначения"),!1):t>this.cities.length-1?(console.log(`Введенное значение ${t} слишком велико. Max значение: ${this.cities.length-1}`),!1):!(t<0&&(console.log(`Введенное значение ${t} не может быть меньше 0`),1))}changeStart(t){this.validate(t)&&(this.start=t,this.showResult())}changeEnd(t){this.validate(t)&&(this.end=t,this.showResult())}init(){document.getElementById("app").innerHTML='<img src="./src/other/findPath/common/graph.png"/>',console.log("Алгоритм Флойда — Уоршелла"),this.fillCityRoads(),this.initMatrix(),this.search()}search(){this.firstFill(),this.recursiveFill(),this.showResult()}}(["zero","one","two","three","four","five","six","seven","eight"],n,0,4)},function(t,e){window.randomInteger=((...t)=>{if(0===t.length)console.log(Math.round(Math.random()));else if(1===t.length){const e=t[0];console.log(Math.round(Math.random()*e))}else{let[e,n]=t;e>n&&([e,n]=[n,e]),console.log(Math.round(e+Math.random()*(n-e)))}})},function(t,e){const n=[[0,0],[3,3],[8,1],[4,-3],[3,-1]],o=t=>{const[e,n,o]=t,s=((t,e,n,o)=>{const[s,i]=t,[r,l]=e,[c,a]=n,[h,u]=o,d=(h*(i*r-l*s-a*r+a*s)+c*(l*s-i*r+u*r-u*s))/(u*(r-s)+a*(s-r)+l*(c-h)+i*(h-c));if(Math.abs(d)===1/0)return console.log("Данные прямые:"),console.log(t,e),console.log(n,o),console.log("Параллельны друг другу"),null;const f=(d*(l-i)-l*s+i*r)/(r-s);return isNaN(f)?null:[d,f]})(e,o,n,[n[0],n[1]+1]);return null===s||(o[0]>e[0]?n[1]>s[1]:o[0]<e[0]?n[1]<s[1]:void 0)};window.polygonConvexity=((t=n)=>{if(!(t=>!(t.length<=3&&(console.log("Вы указали не достаточно точек"),1)))(t))return;const e=(t=>{let e=!0;for(let n=0;n<t.length;n+=1){const s=t[n];if(!o(s)){e=!1;break}}return e})((t=>{const e=[];for(let n=0;n<t.length;n+=1){const o=[];o.push(t[n]);let s=n+1,i=n+2;t[s]?(o.push(t[s]),t[i]?o.push(t[i]):(i=0,o.push(t[i])),e.push(o)):(s=0,i=1,o.push(t[s]),o.push(t[i]),e.push(o))}return e})(t));console.log(t),e?console.log("Многоугольник является выпуклым"):console.log("Многоугольник не является выпуклым")})},function(t,e){window.permutation=((t=5)=>{const e=(t=>{const e=[];let n=1;for(;n<=t;)e.push(n),n++;return e})(t),n=[],o=(t,e)=>{0!==e.length?e.forEach((n,s)=>{const i=[...t],r=[...e];i.push(n),r.splice(s,1),o(i,r)}):n.push(t)};o([],e),console.log(n)})},function(t,e){const n={9:9,1:100,2:3};window.moneybox=new class{constructor(t=10){this.coins=n,this.requestMoney=null,this.weightAllMoney=t,this.startWeight=1,this.weight=Object.create(null)}setCoins(t){this.coins=t,this.setStartWeight()}setWeightAllCoins(t){this.weightAllMoney=t}setRequestMoney(t){this.requestMoney=t}setStartWeight(){const t=Object.keys(this.coins).sort((t,e)=>t-e);this.startWeight=t[0]}hasMoney(t){return this.setRequestMoney(t),this.calc()}calc(){let t=this.startWeight;const e=this.coins,n=this.weight;for(;t<=this.weightAllMoney;){if(!Object.keys(n).length){n[t]=e[t],t++;continue}const o=Object.keys(e),s=[];for(let i=0;i<o.length;i++){const r=Number(o[i]);n[t-r]&&t-r>=0&&s.push(Number(n[t-r])+Number(e[r])),t===r&&s.push(e[r])}s.length&&(n[t]=Math.min.apply(null,s)),t++}return n[this.weightAllMoney]>=this.requestMoney}}},function(t,e,n){"use strict";n.r(e);var o=n(1),s=n(0);window.modules=new class{constructor(t){this.store=new Map,this.resultImport=[],this.history=Object.create(null),this.isError=!1,this.depends=t}initStore(){const{depends:t,store:e}=this;t.forEach(({name:t,depend:n})=>{e.has(t)||e.set(t,new Set),e.get(t).add({depend:n})})}recurciveFindPaths(t,e){const{history:n,resultImport:o,store:s}=this;if(n[t])return;const i=Array.from(s.get(t));for(let r=0;r<i.length;r++){const l=i[r];if(!n[l.depend]){if(e[l.depend])return console.log(`циклическая зависимость на модуле ${t} => ${l.depend}`),void(this.isError=!0);s.has(l.depend)?(e[l.depend]=!0,this.recurciveFindPaths(l.depend,e),o.push(l.depend),n[l.depend]=!0):(e[l.depend]=!0,o.push(l.depend),n[l.depend]=!0)}}}findPaths(){const{store:t,resultImport:e,history:n}=this;for(let o of t.keys()){if(n[o])continue;const t=Object.create(null);t[o]=!0,this.recurciveFindPaths(o,t),e.push(o),n[o]=!0}}showResult(){const{isError:t,resultImport:e}=this;t||console.log(e)}init(){this.initStore(),this.findPaths(),this.showResult()}reset(){this.store.clear(),this.resultImport=[],this.history=Object.create(null),this.isError=!1}changeDepends(t){this.reset(),this.depends=t,this.init()}makeMistake(){this.changeDepends(s)}}(o)},function(t,e){window.bracketsBalance=function(t="{asda asdadasd (asdasd} 5434534}"){const e=[],n={"{":!0,"(":!0,"[":!0},o={"}":"{",")":"(","]":"["};for(let s=0;s<t.length;s++)if(n[t[s]])e.push(t[s]);else if(o[t[s]]){if(e[e.length-1]!==o[t[s]]){console.log(`исходный текст: "${t}"`),console.log(`ошибка на позиции ${s}`);const e=t.slice(0,s-1);return void console.log(`ошибка возникла здесь: "${e}>>${t[s]}<<"`)}e.pop()}e.length?console.log("не закрыты все скобки"):console.log("ошибок нет")}},function(t,e){window.rectAndLine=new class{constructor(){this.rectCoords=[-250,250,-250,250],this.rectWidth=Math.abs(this.rectCoords[1]-this.rectCoords[0]),this.rectHeight=Math.abs(this.rectCoords[3]-this.rectCoords[2]),this.pointA=[-50,-50],this.pointB=[50,50],this.result=[]}findCrossingPoint(t,e,n,o){const[s,i]=t,[r,l]=e,[c,a]=n,[h,u]=o,d=(h*(i*r-l*s-a*r+a*s)+c*(l*s-i*r+u*r-u*s))/(u*(r-s)+a*(s-r)+l*(c-h)+i*(h-c));if(Math.abs(d)===1/0)return console.log("Данные прямые:"),console.log(t,e),console.log(n,o),console.log("Параллельны друг другу"),null;const f=(d*(l-i)-l*s+i*r)/(r-s);return isNaN(f)?null:[d,f]}clear(){const t=document.getElementById("canvas");t&&t.remove()}isNotIdenticalResult([t,e]){let n=!0;return this.result.forEach(([o,s])=>{o===t&&s===e&&(n=!1)}),n}findCrossingPoints(){const[t,e,n,o]=this.rectCoords,s=[t,n],i=[t,o],r=[e,o],l=[e,n];[[s,i],[i,r],[r,l],[l,s]].forEach(([s,i])=>{const r=this.findCrossingPoint(this.pointA,this.pointB,s,i);r&&(r[0]>e||r[0]<t||r[1]>o||r[1]<n||r&&this.isNotIdenticalResult(r)&&this.result.push(r))})}drawRectangle(){const{rectWidth:t,rectHeight:e}=this;this.clear();const n=document.createElement("canvas");n.id="canvas",n.width=t,n.height=e;const o=n.getContext("2d");o.beginPath(),o.moveTo(0,0),o.lineTo(t,0),o.lineTo(t,e),o.lineTo(0,e),o.closePath(),o.strokeStyle="black",o.stroke(),document.getElementById("app").appendChild(n)}drawTextCoords(t,e,n){const{rectWidth:o,rectHeight:s,rectCoords:i}=this,[r,l,c,a]=i;t.font="12pt Arial",t.fillText("0:0",e,s-n+12),t.fillText(`${r}:${c}`,12,s-12),t.fillText(`${r}:${a}`,12,20),t.fillText(`${l}:${a}`,o-70,20),t.fillText(`${l}:${c}`,o-70,s-12)}drawAxis(){const t=document.getElementById("canvas").getContext("2d"),{rectWidth:e,rectHeight:n}=this,{rectCoords:o}=this,s=o[0],i=o[2],r=s<0?-s:0,l=i<0?-i:0;this.drawTextCoords(t,r,l),t.beginPath(),t.moveTo(0,n-l),t.lineTo(e,n-l),t.strokeStyle="red",t.stroke(),t.beginPath(),t.moveTo(r,0),t.lineTo(r,n),t.strokeStyle="red",t.stroke()}drawLine(){const{rectHeight:t}=this;if(this.findCrossingPoints(),2!==this.result.length)return console.log(this.result),void console.log("Нет точек пересечений");const e=document.getElementById("canvas").getContext("2d"),n=this.rectCoords[0],o=this.rectCoords[2],s=n<0?-n:0,i=o<0?-o:0,[r,l]=this.result;e.beginPath(),e.moveTo(r[0]+s,t-r[1]-i),e.lineTo(l[0]+s,t-l[1]-i),e.strokeStyle="black",e.stroke()}drawInputPanel(){if(document.getElementById("rectAndLine"))return;const t=document.getElementById("template_rectAndLine"),e=document.importNode(t.content,!0).children[0];document.getElementById("app").appendChild(e)}init(){document.getElementById("app").innerHTML="",this.draw()}draw(){this.resetResult(),this.drawInputPanel(),this.drawRectangle(),this.drawAxis(),this.drawLine()}resetResult(){this.result=[]}setRectCoords(t,e,n,o){e<t&&([t,e]=[e,t],console.log(`х2 < x1, меняем их значениями. х1 = ${t}; x2 = ${e}`)),o<n&&([n,o]=[o,n],console.log(`y2 < y1, меняем их значениями. y1 = ${n}; x2 = ${o}`)),this.rectCoords=[t,e,n,o],this.rectWidth=Math.abs(e-t),this.rectHeight=Math.abs(o-n),this.draw()}setPoints(t,e){this.pointA=t,this.pointB=e,this.draw()}handlerChangeRectCoords(){const t=document.getElementsByClassName("rectAndLine__input")[0].value;if(!t)return void console.log("Необходимо ввести данные");let e=t.split(",").map(Number);if(4!==e.length)return void console.log("Необходимо ввести 4 числа");const[n,o,s,i]=e;this.setRectCoords(n,o,s,i)}handlerChangePointsCoords(){const t=document.getElementsByClassName("rectAndLine__input")[1].value,e=document.getElementsByClassName("rectAndLine__input")[2].value;if(!t&&!e)return void console.log("Необходимо ввести координаты обоих точек");let n=t.split(",").map(Number),o=e.split(",").map(Number);2===n.length&&2===o.length?this.setPoints(n,o):console.log("Необходимо ввести по 2 числа для каждой точки")}}},function(t,e){window.chess=function(t=8){const e=[];function n(e,n,o){for(let s=-t;s<t;s++){if(0===s)continue;const i=n-s,r=o-s;i>=0&&i<t&&r>=0&&r<t&&(e[i][r]="*");const l=o+s;i>=0&&i<t&&l>=0&&l<t&&(e[i][l]="*")}}function o(e,o,s){for(let i=0;i<t;i++)for(let r=0;r<t;r++)i!==o||r!==s?(n(e,o,s),i!==o&&r!==s||(e[i][r]="*")):e[i][r]=1}function s(n){const s=function(){const e=[];for(let n=1;n<=t;n++)e.push(new Array(t).fill("-"));return e}();let i=0;o(s,i,n),function n(s,i){if(i!==t)for(let e=0;e<t;e++){if("*"===s[i][e]||1===s[i][e])continue;let t=JSON.parse(JSON.stringify(s));o(t,i,e),n(t,i+1)}else e.push(s)}(s,++i)}for(let e=0;e<t;e++)s(e);console.log(e)}},function(t,e){window.polindrom=((t="таррат")=>{console.log(`исходные текст: ${t}`);let e=!0;for(let n=0,o=t.length-1;n<t.length&&n!==o;n++,o--)t[n]!==t[o]&&(e=!1);console.log(`${e?"Полиндром":"Не полиндром"} \n\n`)})},function(t,e){const n={5000:10,2000:10};window.cashMachine=new class{constructor(){this.cash=n,this.step=null,this.start=null}clear(){this.cash=Object.create(null)}getMoney(t){this.init();let{cash:e,start:n}=this;const o=Object.create(null),s=Object.keys(e);for(;n<=t;)if(Object.keys(o).length)if(e[n])o[n]={cash:{...e,[n]:e[n]-1},values:[n]},n+=this.step;else{for(let t=0;t<s.length;t++){const e=Number(s[t]);if(o[n-e]&&n-e>=0){if(0===o[n-e].cash[e])continue;o[n]={cash:{...o[n-e].cash,[e]:o[n-e].cash[e]-1},values:o[n-e].values.concat(e)};break}}n+=this.step}else o[n]={cash:{...e,[n]:e[n]-1},values:[n]},n+=this.step;o[t]?(this.cash={...this.cash,...o[t].cash},console.log(`Успешно ${t} сняли купюрами ${o[t].values}`),console.log("Остались купюры: ",this.cash,"\n\n")):console.log("Нельзя выдать запрашиваемую сумму \n\n")}addMoney(t,e){this.cash[t]||(this.cash[t]=0),this.cash[t]+=e}setStep(){const t=Object.keys(this.cash).sort((t,e)=>t-e);if(this.start=Number(t[0]),1===t.length)return void(this.step=t[0]);const e=t[0],n=t[1];this.step=n%e==0?Number(e):n%e>=1e3?1e3:n%e}init(){this.setStep()}},cashMachine.init(),cashMachine.getMoney(6e3)},function(t,e){window.findSimpleNumber1=((t=100)=>{const e=Array(t+1).fill(!0),n=[2];for(let t=4;t<e.length;t+=2)e[t]=!1;for(let o=3;o<e.length;o+=2){if(!e[o])continue;n.push(o);let s=2*o;for(;s<t;)e[s]=!1,s+=o}console.log(n)}),window.findSimpleNumber2=((t=100)=>{const e=[];t:for(let n=2;n<=t;n++){for(let t=2;t<n;t++)if(n%t==0)continue t;e.push(n)}console.log(e)}),window.findSimpleNumber3=((t=100)=>{const e=[2];t:for(let n=3;n<=t;n+=2){for(let t=3;t<n;t+=2)if(n%t==0)continue t;e.push(n)}console.log(e)})},function(t,e){},function(t,e){const n={value:1,items:[{value:2,items:[{value:4,items:[{value:7},{value:8,items:[{value:11},{value:12}]}]},{value:5,items:[{value:9},{value:10}]}]},{value:3,items:[{value:6}]}]};window.treeWidth=function(t=n){const{value:e,items:o}=t;console.log(e),function t(e){let n=[];e.forEach(t=>{console.log(t.value),t.items&&(n=[...n,...t.items])}),n.length&&t(n)}(o)},treeWidth.default=n},function(t,e){const n={value:1,items:[{value:2,items:[{value:4},{value:5}]},{value:3,items:[{value:6}]}]};window.treeDeep=function(t=n){const{value:e,items:o}=t;console.log(e),o&&o.map(treeDeep)},treeDeep.default=n},function(t,e){const n={value:"a",child:{value:"b",child:{value:"c",child:{value:"d",child:{value:"e",child:null}}}}};window.revertList=function(t=n,e=null){let o;null===t.child?(o={value:t.value,child:e},console.log(`Исходный list: \n ${JSON.stringify(n)}`),console.log(`Результат: \n ${JSON.stringify(o)}`)):(o={value:t.value,child:e},revertList(t.child,o))},revertList.default=n},function(t,e,n){"use strict";n.r(e);const o=[1,[2],[3,[[[4]]]]];e.default=((t=o)=>{const e=[],n=t=>{"number"==typeof t?e.push(t):t.forEach(n)};n(t),console.log(e)})},function(t,e){const n=function(t){const e=Array(t);for(let n=0;n<t;n++)e[n]=n+1;return e}(10);window.binarySearch=((t=5,e=n)=>{console.log(`\n Ищем значение ${t} в массиве:`),console.log(e);const o=e.length-1;let s=0,i=o;t>e[o]?console.log(`Значение ${t} нет в массиве`):function n(){if(i-s==1)return e[s]===t?void console.log(s):e[i]===t?void console.log(i):void console.log("найденного значения нет");let o=Math.floor((i+s)/2);t<e[o]?(i=o,n()):t>e[o]?(s=o,n()):console.log(`index = ${o} \n `)}()})},function(t,e){const n=[-1,2,3,-9,11,-5,-2,35];window.getMaxSubSum=((t=n)=>{let e=0,o=0;for(let n=0;n<t.length;n++)o+=t[n],console.log(o),e=Math.max(e,o),o<0&&(o=0);console.log(e)})},function(t,e){const n=function(){let t=1;return function(e){t>=4&&(t=0);const n=e[t];return t++,n}}();function o(t,e,n,o,s){return t+=n,[t=s[e=s[e+=o]&&"-"===s[e][t]?e:e-o][t]&&"-"===s[e][t]?t:t-n,e]}function s(t,e){const n=e.toString().length;let o=t.toString();for(;o.length<n;)o="0"+o;return o}window.arraySpiral=function(t=4,e){const i=t*(e=e||t),r=[[1,0],[0,1],[-1,0],[0,-1]],l=function(t,e){const n=[];e=e||t;for(let o=0;o<e;o++)n[o]=Array(t).fill("-");return n}(t,e);let c,a,h=0,u=0;[c,a]=r[0];for(let t=1;t<=i;t++)t=s(t,i),l[u]&&l[u][h]&&"-"===l[u][h]?(l[u][h]=t,[h,u]=o(h,u,c,a,l)):([c,a]=n(r),[h,u]=o(h,u,c,a,l),l[u][h]=t,[h,u]=o(h,u,c,a,l));console.dir(l)}},function(t,e){const n=[{name:"test1",value:53},{name:"test2",value:2}];window.reduceArray=function(t=n){const e={};for(let n=0;n<t.length;n++)e[t[n].name]=t[n].value;console.log(e)}},function(t,e){},function(t,e){},function(t,e){window.quickSort=function(){console.log(function t(e=[...defaultArray]){if(0===e.length)return[];const n=[],o=[],s=e[0];for(let t=1;t<e.length;t++)e[t]<s?n.push(e[t]):o.push(e[t]);return t(n).concat(s,t(o))}())}},function(t,e){window.mergeSort=function(t=[...defaultArray]){let e=[];for(let n=0;n<t.length;n+=1)e.push([t[n]]);for(;e.length>1;){const t=[];for(let n=0;n<e.length;n+=2){const o=e[n],s=e[n+1],i=[];if(!s){t.push(o);break}for(;o.length||s.length;)0!==o.length?0!==s.length&&o[0]>s[0]?(i.push(s[0]),s.splice(0,1)):(i.push(o[0]),o.splice(0,1)):(i.push(s[0]),s.splice(0,1));t.push(i)}e=t}console.log(e[0])}},function(t,e){window.insertSort=function(t=[...defaultArray]){let e=t.length-1;for(let n=0;n<=e;n++){if(0===n)continue;let e=n;for(;e&&t[e]<t[e-1];){let n=t[e];t[e]=t[e-1],t[e-1]=n,e-=1}}console.log(t)}},function(t,e){window.choiceSort=function(t=[...defaultArray]){let e=t.length;function n(t){let n=t[0],o=0;for(let s=0;s<e;s++)t[s]>n&&(n=t[s],o=s);return o}for(;0!==e;){let o=n(t);if(o===e){e-=1;continue}const s=t[e-1];t[e-1]=t[o],t[o]=s,e-=1}console.log(t)}},function(t,e){window.bubbleSort=function(t=[...defaultArray]){let e=t.length;for(;e;)n(t),e-=1;function n(t){for(let e=0;e<t.length-1;e++){let n=t[e],o=t[e+1];if(void 0===o)return;n>o&&(t[e]=o,t[e+1]=n)}}console.log(t)}},function(t,e){window.callSortAll=function(){console.log("\n сортировка bubbleSort"),bubbleSort(),console.log("\n сортировка choiceSort"),choiceSort(),console.log("\n сортировка insertSort"),insertSort(),console.log("\n сортировка mergeSort"),mergeSort(),console.log("\n сортировка quickSort"),quickSort(),console.log("\n")}},function(t,e){window.man=(()=>console.log('\nдемо https://thebraid.github.io/algorithms/\n\n1. Сортировка массивов.\n   По умолчанию все функции сортировок используют массив defaultArray = [6, 5, 3, -1, 0, -2, 8, 7, 2, 4, -16, 12, 54, 12, 65].\n   Его можно изменить через глобальную переменную "defaultArray" и все сортировки будут брать этот массив.\n   Или можно передавать нужный массив как 1й аргумент в функцию.\n   Каждая из сортировок не меняет defaultArray.\n   \n   1.0) callSortAll()      - вызовет по очереди все сортировки с массивом по умолчанию.\n   1.1) bubbleSort(array)  - пузырьковая сортировка\n   1.2) choiceSort(array)  - сортировка выбором\n   1.3) insertSort(array)  - сортировка вставками\n   1.4) mergeSort(array)   - сортировка слиянием\n   1.5) quickSort(array)   - быстрая сортировка\n   \n2) Поиск простых чисел\n   Аргумент по умолчанию 100 - т.е. все простые числа до 100.\n\n   2.1) findSimpleNumber1(N) - первый вариант нахождения простых чисел\n   2.2) findSimpleNumber2(N) - улучшенный 1й вариант\n   2.3) findSimpleNumber3(N) - финальный вариант (улучшенный 2й вариант).\n   \n3) Заполнить массив по спирали \n  arraySpiral(NxM) где N = 4 по умолчанию,M = N по умолчанию\n  \n  пример вызова:\n    arraySpiral();    // 4x4\n    arraySpiral(5);   // 5x5\n    arraySpiral(5,7); // 5x7\n    \n4) Бинарный поиск по массиву\n    binarySearch(elem, array), где\n    elem  - элемент который ищем в массиве, по умолчанию = 5;\n    array - массив поиска, по умолчанию = [1,2,3,4,5,6,7,8,9,10]. Массив должен быть упорядоченным.\n    \n5) Баланс скобок в строке.\n   bracketBalance(str), где str по умолчанию = \'{asda asdadasd (asdasd} 5434534}\' (строка с ошибкой)\n   \n6) Расставить ферзей.\n   chess(N), где N по умолчанию = 8 (размер поля 8х8 и ищем расстановку 8 ферзей).\n   Можно задавать размер поля любым, но при значении 12 и свыше вычисления будут занимать длительное время.\n   \n7) Разворот обьекта в обратную сторону.\n  revertList(obj), для просмотра obj по умолчанию набрать "revertList.default"\n \n8) Обход дерева в глубину\n   treeDeep(tree), для просмотра tree по умолчанию набрать "treeDeep.default"\n\n9) Обход дерева в ширину\n   treeWidth(tree), для просмотра tree по умолчанию набрать "treeWidth.default"\n\n10) Нахождение пересечения прямоугольника с координатами x1,x2,y1,y2 с заданными координатами 2 точек прямой.\n   10.1) rectAndLine.draw() - нарисует по умолчанию прямоугольник x1=-250, x2=250, y1=-250, y2=250 и прямую с координатами точек [-5, 1] и [4, 2].\n   10.2) rectAndLine.setRectCoords(x1, x2, y1, y2); - изменит координаты прямоугольника\n   10.3) rectAndLine.setPoints([x1, y1], [x2, y2]);   - изменит координаты точек прямой\n     \n11) Проверка строки на полиндром\n    polindrom(str), str по умолчанию = \'таррат\'\n    \n12) Получение целого числа в заданном диапазоне.\n    randomInteger(), или 0 или 1\n    randomInteger(max), от 0 до max\n    randomInteger(min, max), от min до max\n\n13) Нахождение оптимального пути между графами с помощью алгоритма Флойда — Уоршелла\n    floid.init() - выведет результат поиска по установленному графу в консоль ( + отобразит заднный граф на экране).\n    floid.changeStart(index) - изменит начальную позицию. \n    floid.changeEnd(index) - изменит конечную позицию. \n    \n14) Нахождение оптимального пути между графами с помощью алгоритма Дийкстры\n    dijkstra.init() - выведет результат поиска по установленному графу в консоль ( + отобразит заднный граф на экране).\n    dijkstra.changeStart(index) - изменит начальную позицию. \n    dijkstra.changeEnd(index) - изменит конечную позицию. \n\n15) Импорт модулей в зависимости от их зависимостей, с проверкой на зацикленность.\n    modules.init() - выведет результат о предустановленных зависимостях.\n    modules.changeDepends(newDepends) - задает новые зависимости и отображает результат.\n    modules.makeMistake() - изменит текущие зависимости но новые с циклической зависимостью.\n    \n    modules.depends - покажет текущие зависимости.\n    \n16) Определение суммы наибольшего подмассива\n    getMaxSubSum(array), где array по умолчанию = [-1, 2, 3, -9, 11, -5, -2, 35];\n    \n17) Определение выпуклости многоугольника\n    polygonConvexity(array), где array по умолчанию = [[0,0], [3,3], [8,1], [4,-3], [3,-1]]  (это не выпуклый многоугольник)\n\n18) Определение, точно ли в копилке наберется нужная сумма.\n    moneybox.setCoins(coins) - задает возможный набор монет, в формате {вес: номинал монеты, ...},\n    по умолчанию coins = { 9: 9, 1: 100, 2: 3 };\n    moneybox.setWeightAllCoins(20) - задает вес монет, по умолчанию = 10.\n    moneybox.hasMoney(16) - проверяет, точно ли наберется сумма 16.\n'))},function(t,e,n){window.defaultArray=[6,5,3,-1,0,-2,8,7,2,4,-16,12,54,12,65];n(33),n(32),n(31),n(30),n(29),n(28),n(27),n(26),n(25),n(24),n(23),n(22),n(21),n(20),n(19),n(18),n(17),n(16),n(15),n(14),n(13),n(12),n(11),n(10),n(9),n(8),n(7),n(6),n(5),n(4),n(3),n(2)},function(t,e,n){t.exports=n(34)}]);