!function(t){var e={};function o(n){if(e[n])return e[n].exports;var s=e[n]={i:n,l:!1,exports:{}};return t[n].call(s.exports,s,s.exports,o),s.l=!0,s.exports}o.m=t,o.c=e,o.d=function(t,e,n){o.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:n})},o.r=function(t){Object.defineProperty(t,"__esModule",{value:!0})},o.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return o.d(e,"a",e),e},o.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},o.p="",o(o.s=35)}([function(t){t.exports=[{name:"module1",depend:"module2"},{name:"module2",depend:"module3"},{name:"module2",depend:"module4"},{name:"module3",depend:"module4"},{name:"module4",depend:"module1"}]},function(t){t.exports=[{name:"module1",depend:"module2"},{name:"module2",depend:"module3"},{name:"module2",depend:"module4"},{name:"module3",depend:"module4"},{name:"module5",depend:"module4"},{name:"module8",depend:"module7"},{name:"module8",depend:"module6"},{name:"module7",depend:"module4"},{name:"module6",depend:"module5"}]},function(t,e){},function(t,e){window.dijkstra=new class{constructor(t,e,o,n){this.cities=t,this.roads=e,this.start=o,this.end=n,this.citiesRoads=Object.create(null),this.history=Object.create(null)}fillCityRoads(){const{citiesRoads:t,roads:e}=this;e.forEach(({from:e,to:o,km:n})=>{t[e]||(t[e]=[]),t[o]||(t[o]=[]),t[e].push({from:e,to:o,km:n}),t[o].push({from:o,to:e,km:n})})}init(){document.getElementById("app").innerHTML='<img src="./src/other/findPath/common/graph.png"/>',console.log("Алгоритм Дийсктры"),this.fillCityRoads(),this.search()}getDistance(t){if(null===t)return 1/0;if(Array.isArray(t)){let e=0;return t.forEach(t=>{e+=t.km}),e}return t.km}recurciveSearch(t){if(t.every(t=>t.done))return;const{citiesRoads:e,history:o}=this;let n=[];t.forEach(t=>{const{start:s,nodes:i}=t;o[s]={...o[s],done:!0},i.forEach(t=>{if(o[t.to]&&o[t.to].done)return;if(o[t.to]){const e=o[t.to].path,n=this.getDistance(e);if(isFinite(n)){const e=this.getDistance(o[t.from].path),n=this.getDistance(t);if(this.getDistance(o[t.to].path)<e+n)return;o[t.to]={...o[t.to],path:o[t.from].path.concat(t)}}else o[t.to]={...o[t.to],path:[t]}}else{let e=[];const n=o[t.from].path;e=n?n.concat(t):[t],o[t.to]={done:!1,path:e}}let i=e[t.to];i=i.filter(t=>t.to!==s),n=n.concat({start:t.to,nodes:i})})}),this.count++,this.recurciveSearch(n)}search(){const{citiesRoads:t,start:e}=this,o=t[e];this.recurciveSearch([{start:e,nodes:o}]),this.showResult()}showResult(){const{start:t,end:e}=this;console.log(this.history);const o=this.history[e].path,n=this.getDistance(o);let s="";for(let t=0;t<o.length;t++)0!==t?(o.length,s+=` > ${o[t].to}`):s+=`${o[t].from} > ${o[t].to}`;console.log(`Минимальное рассояние от точки ${t} до ${e}: ${n}km`),console.log(`Необходимо пройти следующий путь: ${s}\n\n`)}validate(t){return t===this.start?(console.log("Введеное значение равно точке старта"),!1):t===this.end?(console.log("Введеное значение равно точке назначения"),!1):t>this.cities.length-1?(console.log(`Введенное значение ${t} слишком велико. Max значение: ${this.cities.length-1}`),!1):!(t<0&&(console.log(`Введенное значение ${t} не может быть меньше 0`),1))}clear(){this.history=Object.create(null)}changeEnd(t){this.validate(t)&&(this.end=t,this.showResult())}changeStart(t){this.validate(t)&&(this.clear(),this.start=t,this.search())}}(["zero","one","two","three","four","five","six","seven","eight"],[{from:0,to:1,km:1},{from:1,to:3,km:4},{from:3,to:4,km:4},{from:0,to:2,km:3},{from:2,to:4,km:7},{from:5,to:3,km:9},{from:5,to:0,km:3},{from:3,to:7,km:2},{from:4,to:8,km:1},{from:8,to:7,km:2},{from:2,to:6,km:6},{from:6,to:4,km:3},{from:6,to:7,km:4}],0,4)},function(t,e){const o=[{from:0,to:1,km:1},{from:1,to:3,km:4},{from:3,to:4,km:4},{from:0,to:2,km:3},{from:2,to:4,km:7},{from:5,to:3,km:9},{from:5,to:0,km:3},{from:3,to:7,km:2},{from:4,to:8,km:1},{from:8,to:7,km:2},{from:2,to:6,km:6},{from:6,to:4,km:3},{from:6,to:7,km:4}];window.floid=new class{constructor(t,e,o,n){this.cities=t,this.roads=e,this.start=o,this.end=n,this.citiesRoads=Object.create(null),this.matrix=[]}fillCityRoads(){const{citiesRoads:t}=this;o.forEach(({from:e,to:o,km:n})=>{t[e]||(t[e]=[]),t[o]||(t[o]=[]),t[e].push({to:o,km:n}),t[o].push({to:e,km:n})})}initMatrix(){const t=this.cities.length;for(let e=0;e<t;e+=1){this.matrix[e]=[];for(let o=0;o<t;o+=1)e!==o?this.matrix[e].push("-"):this.matrix[e].push(0)}}firstFill(){const{citiesRoads:t}=this;for(let e in t)t[e].forEach(({to:t,km:o})=>{this.matrix[e][t]={from:Number(e),to:t,km:o}})}getTotalDistance(t){return Array.isArray(t)?t.reduce((t,e)=>t+e.km,0):t.km}recursiveFill(t=0){const e=this.cities.length;if(t===e)return;const{matrix:o}=this;for(let n=0;n<e;n+=1)if(n!==t)for(let s=0;s<e;s+=1){if(s===t)continue;if(0===o[n][s])continue;if("-"===o[t][s])continue;if("-"===o[n][t])continue;const e=[].concat(o[n][t],o[t][s]);"-"!==o[n][s]&&this.getTotalDistance(o[n][s])<this.getTotalDistance(e)||(this.matrix[n][s]=[].concat(o[n][t],o[t][s]))}t++,this.recursiveFill(t)}getPath(){const{matrix:t,start:e,end:o,cities:n}=this,s=t[e][o];if(Array.isArray(s)){let t="";for(let e=0;e<s.length;e+=1)0!==e?e!==s.length-1?t+=`> ${n[s[e].to]}(${s[e].to})`:t+=` > ${n[s[e].to]}(${s[e].to})`:t+=`${n[s[e].from]}(${s[e].from}) > ${n[s[e].to]}(${s[e].to})`;return t}return`${s.from} > ${s.to}`}showResult(){const{matrix:t,start:e,end:o}=this,n=this.getTotalDistance(t[e][o]);console.log(`Минимальное рассояние от точки ${e} до ${o}: ${n}km`);const s=this.getPath();console.log(`Необходимо пройти следующий путь: ${s}\n\n`),console.log(this.citiesRoads)}validate(t){return t===this.start?(console.log("Введеное значение равно точке старта"),!1):t===this.end?(console.log("Введеное значение равно точке назначения"),!1):t>this.cities.length-1?(console.log(`Введенное значение ${t} слишком велико. Max значение: ${this.cities.length-1}`),!1):!(t<0&&(console.log(`Введенное значение ${t} не может быть меньше 0`),1))}changeStart(t){this.validate(t)&&(this.start=t,this.showResult())}changeEnd(t){this.validate(t)&&(this.end=t,this.showResult())}init(){document.getElementById("app").innerHTML='<img src="./src/other/findPath/common/graph.png"/>',console.log("Алгоритм Флойда — Уоршелла"),this.fillCityRoads(),this.initMatrix(),this.search()}search(){this.firstFill(),this.recursiveFill(),this.showResult()}}(["zero","one","two","three","four","five","six","seven","eight"],o,0,4)},function(t,e){window.randomInteger=((...t)=>{if(0===t.length)console.log(Math.round(Math.random()));else if(1===t.length){const e=t[0];console.log(Math.round(Math.random()*e))}else{let[e,o]=t;e>o&&([e,o]=[o,e]),console.log(Math.round(e+Math.random()*(o-e)))}})},function(t,e){const o=[[0,0],[3,3],[8,1],[4,-3],[3,-1]],n=t=>{const[e,o,n]=t,s=((t,e,o,n)=>{const[s,i]=t,[r,l]=e,[c,a]=o,[h,u]=n,d=(h*(i*r-l*s-a*r+a*s)+c*(l*s-i*r+u*r-u*s))/(u*(r-s)+a*(s-r)+l*(c-h)+i*(h-c));if(Math.abs(d)===1/0)return console.log("Данные прямые:"),console.log(t,e),console.log(o,n),console.log("Параллельны друг другу"),null;const f=(d*(l-i)-l*s+i*r)/(r-s);return isNaN(f)?null:[d,f]})(e,n,o,[o[0],o[1]+1]);return null===s||(n[0]>e[0]?o[1]>s[1]:n[0]<e[0]?o[1]<s[1]:void 0)};window.polygonConvexity=((t=o)=>{if(!(t=>!(t.length<=3&&(console.log("Вы указали не достаточно точек"),1)))(t))return;const e=(t=>{let e=!0;for(let o=0;o<t.length;o+=1){const s=t[o];if(!n(s)){e=!1;break}}return e})((t=>{const e=[];for(let o=0;o<t.length;o+=1){const n=[];n.push(t[o]);let s=o+1,i=o+2;t[s]?(n.push(t[s]),t[i]?n.push(t[i]):(i=0,n.push(t[i])),e.push(n)):(s=0,i=1,n.push(t[s]),n.push(t[i]),e.push(n))}return e})(t));console.log(t),e?console.log("Многоугольник является выпуклым"):console.log("Многоугольник не является выпуклым")})},function(t,e){window.permutation=((t=5)=>{const e=(t=>{const e=[];let o=1;for(;o<=t;)e.push(o),o++;return e})(t),o=[],n=(t,e)=>{0!==e.length?e.forEach((o,s)=>{const i=[...t],r=[...e];i.push(o),r.splice(s,1),n(i,r)}):o.push(t)};n([],e),console.log(o)})},function(t,e){const o={9:9,1:100,2:3};window.moneybox=new class{constructor(t=10){this.coins=o,this.requestMoney=null,this.weightAllMoney=t,this.startWeight=1,this.weight=Object.create(null)}setCoins(t){this.coins=t,this.setStartWeight()}setWeightAllCoins(t){this.weightAllMoney=t}setRequestMoney(t){this.requestMoney=t}setStartWeight(){const t=Object.keys(this.coins).sort((t,e)=>t-e);this.startWeight=t[0]}hasMoney(t){return this.setRequestMoney(t),this.calc()}calc(){let t=this.startWeight;const e=this.coins,o=this.weight;for(;t<=this.weightAllMoney;){if(!Object.keys(o).length){o[t]=e[t],t++;continue}const n=Object.keys(e),s=[];for(let i=0;i<n.length;i++){const r=Number(n[i]);o[t-r]&&t-r>=0&&s.push(Number(o[t-r])+Number(e[r])),t===r&&s.push(e[r])}s.length&&(o[t]=Math.min.apply(null,s)),t++}return o[this.weightAllMoney]>=this.requestMoney}}},function(t,e,o){"use strict";o.r(e);var n=o(1),s=o(0);window.modules=new class{constructor(t){this.store=new Map,this.resultImport=[],this.history=Object.create(null),this.isError=!1,this.depends=t}initStore(){const{depends:t,store:e}=this;t.forEach(({name:t,depend:o})=>{e.has(t)||e.set(t,new Set),e.get(t).add({depend:o})})}recurciveFindPaths(t,e){const{history:o,resultImport:n,store:s}=this;if(o[t])return;const i=Array.from(s.get(t));for(let r=0;r<i.length;r++){const l=i[r];if(!o[l.depend]){if(e[l.depend])return console.log(`циклическая зависимость на модуле ${t} => ${l.depend}`),void(this.isError=!0);s.has(l.depend)?(e[l.depend]=!0,this.recurciveFindPaths(l.depend,e),n.push(l.depend),o[l.depend]=!0):(e[l.depend]=!0,n.push(l.depend),o[l.depend]=!0)}}}findPaths(){const{store:t,resultImport:e,history:o}=this;for(let n of t.keys()){if(o[n])continue;const t=Object.create(null);t[n]=!0,this.recurciveFindPaths(n,t),e.push(n),o[n]=!0}}showResult(){const{isError:t,resultImport:e}=this;t||console.log(e)}init(){this.initStore(),this.findPaths(),this.showResult()}reset(){this.store.clear(),this.resultImport=[],this.history=Object.create(null),this.isError=!1}changeDepends(t){this.reset(),this.depends=t,this.init()}makeMistake(){this.changeDepends(s)}}(n)},function(t,e){window.bracketsBalance=function(t="{asda asdadasd (asdasd} 5434534}"){const e=[],o={"{":!0,"(":!0,"[":!0},n={"}":"{",")":"(","]":"["};for(let s=0;s<t.length;s++)if(o[t[s]])e.push(t[s]);else if(n[t[s]]){if(e[e.length-1]!==n[t[s]]){console.log(`исходный текст: "${t}"`),console.log(`ошибка на позиции ${s}`);const e=t.slice(0,s-1);return void console.log(`ошибка возникла здесь: "${e}>>${t[s]}<<"`)}e.pop()}e.length?console.log("не закрыты все скобки"):console.log("ошибок нет")}},function(t,e){window.rectAndLine=new class{constructor(){this.rectCoords=[-250,250,-250,250],this.rectWidth=Math.abs(this.rectCoords[1]-this.rectCoords[0]),this.rectHeight=Math.abs(this.rectCoords[3]-this.rectCoords[2]),this.pointA=[-50,-50],this.pointB=[50,50],this.result=[]}findCrossingPoint(t,e,o,n){const[s,i]=t,[r,l]=e,[c,a]=o,[h,u]=n,d=(h*(i*r-l*s-a*r+a*s)+c*(l*s-i*r+u*r-u*s))/(u*(r-s)+a*(s-r)+l*(c-h)+i*(h-c));if(Math.abs(d)===1/0)return console.log("Данные прямые:"),console.log(t,e),console.log(o,n),console.log("Параллельны друг другу"),null;const f=(d*(l-i)-l*s+i*r)/(r-s);return isNaN(f)?null:[d,f]}clear(){const t=document.getElementById("canvas");t&&t.remove()}isNotIdenticalResult([t,e]){let o=!0;return this.result.forEach(([n,s])=>{n===t&&s===e&&(o=!1)}),o}findCrossingPoints(){const[t,e,o,n]=this.rectCoords,s=[t,o],i=[t,n],r=[e,n],l=[e,o];[[s,i],[i,r],[r,l],[l,s]].forEach(([s,i])=>{const r=this.findCrossingPoint(this.pointA,this.pointB,s,i);r&&(r[0]>e||r[0]<t||r[1]>n||r[1]<o||r&&this.isNotIdenticalResult(r)&&this.result.push(r))})}drawRectangle(){const{rectWidth:t,rectHeight:e}=this;this.clear();const o=document.createElement("canvas");o.id="canvas",o.width=t,o.height=e;const n=o.getContext("2d");n.beginPath(),n.moveTo(0,0),n.lineTo(t,0),n.lineTo(t,e),n.lineTo(0,e),n.closePath(),n.strokeStyle="black",n.stroke(),document.getElementById("app").appendChild(o)}drawTextCoords(t,e,o){const{rectWidth:n,rectHeight:s,rectCoords:i}=this,[r,l,c,a]=i;t.font="12pt Arial",t.fillText("0:0",e,s-o+12),t.fillText(`${r}:${c}`,12,s-12),t.fillText(`${r}:${a}`,12,20),t.fillText(`${l}:${a}`,n-70,20),t.fillText(`${l}:${c}`,n-70,s-12)}drawAxis(){const t=document.getElementById("canvas").getContext("2d"),{rectWidth:e,rectHeight:o}=this,{rectCoords:n}=this,s=n[0],i=n[2],r=s<0?-s:0,l=i<0?-i:0;this.drawTextCoords(t,r,l),t.beginPath(),t.moveTo(0,o-l),t.lineTo(e,o-l),t.strokeStyle="red",t.stroke(),t.beginPath(),t.moveTo(r,0),t.lineTo(r,o),t.strokeStyle="red",t.stroke()}drawLine(){const{rectHeight:t}=this;if(this.findCrossingPoints(),2!==this.result.length)return console.log(this.result),void console.log("Нет точек пересечений");const e=document.getElementById("canvas").getContext("2d"),o=this.rectCoords[0],n=this.rectCoords[2],s=o<0?-o:0,i=n<0?-n:0,[r,l]=this.result;e.beginPath(),e.moveTo(r[0]+s,t-r[1]-i),e.lineTo(l[0]+s,t-l[1]-i),e.strokeStyle="black",e.stroke()}drawInputPanel(){if(document.getElementById("rectAndLine"))return;const t=document.getElementById("template_rectAndLine"),e=document.importNode(t.content,!0).children[0];document.getElementById("app").appendChild(e)}init(){document.getElementById("app").innerHTML="",this.draw()}draw(){this.resetResult(),this.drawInputPanel(),this.drawRectangle(),this.drawAxis(),this.drawLine()}resetResult(){this.result=[]}setRectCoords(t,e,o,n){e<t&&([t,e]=[e,t],console.log(`х2 < x1, меняем их значениями. х1 = ${t}; x2 = ${e}`)),n<o&&([o,n]=[n,o],console.log(`y2 < y1, меняем их значениями. y1 = ${o}; x2 = ${n}`)),this.rectCoords=[t,e,o,n],this.rectWidth=Math.abs(e-t),this.rectHeight=Math.abs(n-o),this.draw()}setPoints(t,e){this.pointA=t,this.pointB=e,this.draw()}handlerChangeRectCoords(){const t=document.getElementsByClassName("rectAndLine__input")[0].value;if(!t)return void console.log("Необходимо ввести данные");let e=t.split(",").map(Number);if(4!==e.length)return void console.log("Необходимо ввести 4 числа");const[o,n,s,i]=e;this.setRectCoords(o,n,s,i)}handlerChangePointsCoords(){const t=document.getElementsByClassName("rectAndLine__input")[1].value,e=document.getElementsByClassName("rectAndLine__input")[2].value;if(!t&&!e)return void console.log("Необходимо ввести координаты обоих точек");let o=t.split(",").map(Number),n=e.split(",").map(Number);2===o.length&&2===n.length?this.setPoints(o,n):console.log("Необходимо ввести по 2 числа для каждой точки")}}},function(t,e){window.chess=function(t=8){const e=[];function o(e,o,n){for(let s=-t;s<t;s++){if(0===s)continue;const i=o-s,r=n-s;i>=0&&i<t&&r>=0&&r<t&&(e[i][r]="*");const l=n+s;i>=0&&i<t&&l>=0&&l<t&&(e[i][l]="*")}}function n(e,n,s){for(let i=0;i<t;i++)for(let r=0;r<t;r++)i!==n||r!==s?(o(e,n,s),i!==n&&r!==s||(e[i][r]="*")):e[i][r]=1}function s(o){const s=function(){const e=[];for(let o=1;o<=t;o++)e.push(new Array(t).fill("-"));return e}();let i=0;n(s,i,o),function o(s,i){if(i!==t)for(let e=0;e<t;e++){if("*"===s[i][e]||1===s[i][e])continue;let t=JSON.parse(JSON.stringify(s));n(t,i,e),o(t,i+1)}else e.push(s)}(s,++i)}for(let e=0;e<t;e++)s(e);console.log(e)}},function(t,e){window.polindrom=((t="таррат")=>{console.log(`исходные текст: ${t}`);let e=!0;for(let o=0,n=t.length-1;o<t.length&&o!==n;o++,n--)t[o]!==t[n]&&(e=!1);console.log(`${e?"Полиндром":"Не полиндром"} \n\n`)})},function(t,e){const o={15000:10,13000:10,7000:10};new class{constructor(){this.cash=o,this.step=null,this.start=null}clear(){this.cash=Object.create(null)}getMoney(t){this.init();let e=this.cash,o=this.start;const n=Object.create(null),s=Object.keys(e);for(;o<=2e4;)if(Object.keys(n).length)if(e[o])n[o]=[o],e[o]-=1,o+=this.step;else{for(let t=0;t<s.length;t++){const i=Number(s[t]);if(n[o-i]&&o-i>=0){e[i]-=1,console.log(o),n[o]=n[o-i].concat(i);break}}o+=this.step}else n[o]=[o],e[o]-=1,o+=this.step;console.log(e)}addMoney(t,e){this.cash[t]||(this.cash[t]=0),this.cash[t]+=e}setStep(){const t=Object.keys(this.cash).sort((t,e)=>t-e);if(this.start=Number(t[0]),1===t.length)return void(this.step=t[0]);const e=t[0],o=t[1];this.step=o%e==0?Number(e):o%e>=1e3?1e3:o%e}init(){this.setStep()}}},function(t,e){window.findSimpleNumber1=((t=100)=>{const e=Array(t+1).fill(!0),o=[2];for(let t=4;t<e.length;t+=2)e[t]=!1;for(let n=3;n<e.length;n+=2){if(!e[n])continue;o.push(n);let s=2*n;for(;s<t;)e[s]=!1,s+=n}console.log(o)}),window.findSimpleNumber2=((t=100)=>{const e=[];t:for(let o=2;o<=t;o++){for(let t=2;t<o;t++)if(o%t==0)continue t;e.push(o)}console.log(e)}),window.findSimpleNumber3=((t=100)=>{const e=[2];t:for(let o=3;o<=t;o+=2){for(let t=3;t<o;t+=2)if(o%t==0)continue t;e.push(o)}console.log(e)})},function(t,e){},function(t,e){const o={value:1,items:[{value:2,items:[{value:4,items:[{value:7},{value:8,items:[{value:11},{value:12}]}]},{value:5,items:[{value:9},{value:10}]}]},{value:3,items:[{value:6}]}]};window.treeWidth=function(t=o){const{value:e,items:n}=t;console.log(e),function t(e){let o=[];e.forEach(t=>{console.log(t.value),t.items&&(o=[...o,...t.items])}),o.length&&t(o)}(n)},treeWidth.default=o},function(t,e){const o={value:1,items:[{value:2,items:[{value:4},{value:5}]},{value:3,items:[{value:6}]}]};window.treeDeep=function(t=o){const{value:e,items:n}=t;console.log(e),n&&n.map(treeDeep)},treeDeep.default=o},function(t,e){const o={value:"a",child:{value:"b",child:{value:"c",child:{value:"d",child:{value:"e",child:null}}}}};window.revertList=function(t=o,e=null){let n;null===t.child?(n={value:t.value,child:e},console.log(`Исходный list: \n ${JSON.stringify(o)}`),console.log(`Результат: \n ${JSON.stringify(n)}`)):(n={value:t.value,child:e},revertList(t.child,n))},revertList.default=o},function(t,e,o){"use strict";o.r(e);const n=[1,[2],[3,[[[4]]]]];e.default=((t=n)=>{const e=[],o=t=>{"number"==typeof t?e.push(t):t.forEach(o)};o(t),console.log(e)})},function(t,e){const o=function(t){const e=Array(t);for(let o=0;o<t;o++)e[o]=o+1;return e}(10);window.binarySearch=((t=5,e=o)=>{console.log(`\n Ищем значение ${t} в массиве:`),console.log(e);const n=e.length-1;let s=0,i=n;t>e[n]?console.log(`Значение ${t} нет в массиве`):function o(){if(i-s==1)return e[s]===t?void console.log(s):e[i]===t?void console.log(i):void console.log("найденного значения нет");let n=Math.floor((i+s)/2);t<e[n]?(i=n,o()):t>e[n]?(s=n,o()):console.log(`index = ${n} \n `)}()})},function(t,e){const o=[-1,2,3,-9,11,-5,-2,35];window.getMaxSubSum=((t=o)=>{let e=0,n=0;for(let o=0;o<t.length;o++)n+=t[o],console.log(n),e=Math.max(e,n),n<0&&(n=0);console.log(e)})},function(t,e){const o=function(){let t=1;return function(e){t>=4&&(t=0);const o=e[t];return t++,o}}();function n(t,e,o,n,s){return t+=o,[t=s[e=s[e+=n]&&"-"===s[e][t]?e:e-n][t]&&"-"===s[e][t]?t:t-o,e]}function s(t,e){const o=e.toString().length;let n=t.toString();for(;n.length<o;)n="0"+n;return n}window.arraySpiral=function(t=4,e){const i=t*(e=e||t),r=[[1,0],[0,1],[-1,0],[0,-1]],l=function(t,e){const o=[];e=e||t;for(let n=0;n<e;n++)o[n]=Array(t).fill("-");return o}(t,e);let c,a,h=0,u=0;[c,a]=r[0];for(let t=1;t<=i;t++)t=s(t,i),l[u]&&l[u][h]&&"-"===l[u][h]?(l[u][h]=t,[h,u]=n(h,u,c,a,l)):([c,a]=o(r),[h,u]=n(h,u,c,a,l),l[u][h]=t,[h,u]=n(h,u,c,a,l));console.dir(l)}},function(t,e){const o=[{name:"test1",value:53},{name:"test2",value:2}];window.reduceArray=function(t=o){const e={};for(let o=0;o<t.length;o++)e[t[o].name]=t[o].value;console.log(e)}},function(t,e){},function(t,e){},function(t,e){window.quickSort=function(){console.log(function t(e=[...defaultArray]){if(0===e.length)return[];const o=[],n=[],s=e[0];for(let t=1;t<e.length;t++)e[t]<s?o.push(e[t]):n.push(e[t]);return t(o).concat(s,t(n))}())}},function(t,e){window.mergeSort=function(t=[...defaultArray]){let e=[];for(let o=0;o<t.length;o+=1)e.push([t[o]]);for(;e.length>1;){const t=[];for(let o=0;o<e.length;o+=2){const n=e[o],s=e[o+1],i=[];if(!s){t.push(n);break}for(;n.length||s.length;)0!==n.length?0!==s.length&&n[0]>s[0]?(i.push(s[0]),s.splice(0,1)):(i.push(n[0]),n.splice(0,1)):(i.push(s[0]),s.splice(0,1));t.push(i)}e=t}console.log(e[0])}},function(t,e){window.insertSort=function(t=[...defaultArray]){let e=t.length-1;for(let o=0;o<=e;o++){if(0===o)continue;let e=o;for(;e&&t[e]<t[e-1];){let o=t[e];t[e]=t[e-1],t[e-1]=o,e-=1}}console.log(t)}},function(t,e){window.choiceSort=function(t=[...defaultArray]){let e=t.length;function o(t){let o=t[0],n=0;for(let s=0;s<e;s++)t[s]>o&&(o=t[s],n=s);return n}for(;0!==e;){let n=o(t);if(n===e){e-=1;continue}const s=t[e-1];t[e-1]=t[n],t[n]=s,e-=1}console.log(t)}},function(t,e){window.bubbleSort=function(t=[...defaultArray]){let e=t.length;for(;e;)o(t),e-=1;function o(t){for(let e=0;e<t.length-1;e++){let o=t[e],n=t[e+1];if(void 0===n)return;o>n&&(t[e]=n,t[e+1]=o)}}console.log(t)}},function(t,e){window.callSortAll=function(){console.log("\n сортировка bubbleSort"),bubbleSort(),console.log("\n сортировка choiceSort"),choiceSort(),console.log("\n сортировка insertSort"),insertSort(),console.log("\n сортировка mergeSort"),mergeSort(),console.log("\n сортировка quickSort"),quickSort(),console.log("\n")}},function(t,e){window.man=(()=>console.log('\nдемо https://thebraid.github.io/algorithms/\n\n1. Сортировка массивов.\n   По умолчанию все функции сортировок используют массив defaultArray = [6, 5, 3, -1, 0, -2, 8, 7, 2, 4, -16, 12, 54, 12, 65].\n   Его можно изменить через глобальную переменную "defaultArray" и все сортировки будут брать этот массив.\n   Или можно передавать нужный массив как 1й аргумент в функцию.\n   Каждая из сортировок не меняет defaultArray.\n   \n   1.0) callSortAll()      - вызовет по очереди все сортировки с массивом по умолчанию.\n   1.1) bubbleSort(array)  - пузырьковая сортировка\n   1.2) choiceSort(array)  - сортировка выбором\n   1.3) insertSort(array)  - сортировка вставками\n   1.4) mergeSort(array)   - сортировка слиянием\n   1.5) quickSort(array)   - быстрая сортировка\n   \n2) Поиск простых чисел\n   Аргумент по умолчанию 100 - т.е. все простые числа до 100.\n\n   2.1) findSimpleNumber1(N) - первый вариант нахождения простых чисел\n   2.2) findSimpleNumber2(N) - улучшенный 1й вариант\n   2.3) findSimpleNumber3(N) - финальный вариант (улучшенный 2й вариант).\n   \n3) Заполнить массив по спирали \n  arraySpiral(NxM) где N = 4 по умолчанию,M = N по умолчанию\n  \n  пример вызова:\n    arraySpiral();    // 4x4\n    arraySpiral(5);   // 5x5\n    arraySpiral(5,7); // 5x7\n    \n4) Бинарный поиск по массиву\n    binarySearch(elem, array), где\n    elem  - элемент который ищем в массиве, по умолчанию = 5;\n    array - массив поиска, по умолчанию = [1,2,3,4,5,6,7,8,9,10]. Массив должен быть упорядоченным.\n    \n5) Баланс скобок в строке.\n   bracketBalance(str), где str по умолчанию = \'{asda asdadasd (asdasd} 5434534}\' (строка с ошибкой)\n   \n6) Расставить ферзей.\n   chess(N), где N по умолчанию = 8 (размер поля 8х8 и ищем расстановку 8 ферзей).\n   Можно задавать размер поля любым, но при значении 12 и свыше вычисления будут занимать длительное время.\n   \n7) Разворот обьекта в обратную сторону.\n  revertList(obj), для просмотра obj по умолчанию набрать "revertList.default"\n \n8) Обход дерева в глубину\n   treeDeep(tree), для просмотра tree по умолчанию набрать "treeDeep.default"\n\n9) Обход дерева в ширину\n   treeWidth(tree), для просмотра tree по умолчанию набрать "treeWidth.default"\n\n10) Нахождение пересечения прямоугольника с координатами x1,x2,y1,y2 с заданными координатами 2 точек прямой.\n   10.1) rectAndLine.draw() - нарисует по умолчанию прямоугольник x1=-250, x2=250, y1=-250, y2=250 и прямую с координатами точек [-5, 1] и [4, 2].\n   10.2) rectAndLine.setRectCoords(x1, x2, y1, y2); - изменит координаты прямоугольника\n   10.3) rectAndLine.setPoints([x1, y1], [x2, y2]);   - изменит координаты точек прямой\n     \n11) Проверка строки на полиндром\n    polindrom(str), str по умолчанию = \'таррат\'\n    \n12) Получение целого числа в заданном диапазоне.\n    randomInteger(), или 0 или 1\n    randomInteger(max), от 0 до max\n    randomInteger(min, max), от min до max\n\n13) Нахождение оптимального пути между графами с помощью алгоритма Флойда — Уоршелла\n    floid.init() - выведет результат поиска по установленному графу в консоль ( + отобразит заднный граф на экране).\n    floid.changeStart(index) - изменит начальную позицию. \n    floid.changeEnd(index) - изменит конечную позицию. \n    \n14) Нахождение оптимального пути между графами с помощью алгоритма Дийкстры\n    dijkstra.init() - выведет результат поиска по установленному графу в консоль ( + отобразит заднный граф на экране).\n    dijkstra.changeStart(index) - изменит начальную позицию. \n    dijkstra.changeEnd(index) - изменит конечную позицию. \n\n15) Импорт модулей в зависимости от их зависимостей, с проверкой на зацикленность.\n    modules.init() - выведет результат о предустановленных зависимостях.\n    modules.changeDepends(newDepends) - задает новые зависимости и отображает результат.\n    modules.makeMistake() - изменит текущие зависимости но новые с циклической зависимостью.\n    \n    modules.depends - покажет текущие зависимости.\n    \n16) Определение суммы наибольшего подмассива\n    getMaxSubSum(array), где array по умолчанию = [-1, 2, 3, -9, 11, -5, -2, 35];\n    \n17) Определение выпуклости многоугольника\n    polygonConvexity(array), где array по умолчанию = [[0,0], [3,3], [8,1], [4,-3], [3,-1]]  (это не выпуклый многоугольник)\n\n18) Определение, точно ли в копилке наберется нужная сумма.\n    moneybox.setCoins(coins) - задает возможный набор монет, в формате {вес: номинал монеты, ...},\n    по умолчанию coins = { 9: 9, 1: 100, 2: 3 };\n    moneybox.setWeightAllCoins(20) - задает вес монет, по умолчанию = 10.\n    moneybox.hasMoney(16) - проверяет, точно ли наберется сумма 16.\n'))},function(t,e,o){window.defaultArray=[6,5,3,-1,0,-2,8,7,2,4,-16,12,54,12,65];o(33),o(32),o(31),o(30),o(29),o(28),o(27),o(26),o(25),o(24),o(23),o(22),o(21),o(20),o(19),o(18),o(17),o(16),o(15),o(14),o(13),o(12),o(11),o(10),o(9),o(8),o(7),o(6),o(5),o(4),o(3),o(2)},function(t,e,o){t.exports=o(34)}]);